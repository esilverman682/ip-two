{"version":3,"file":"use-tweaks.cjs.production.min.js","sources":["../src/types.ts","../src/data.ts","../src/useTweaks.ts","../src/helpers.ts"],"sourcesContent":["import { InputParams, MonitorParams } from 'tweakpane/dist/types/api/types'\nimport { TweakpaneConfig } from 'tweakpane/dist/types/tweakpane-config'\nimport { FolderApi } from 'tweakpane/dist/types/api/folder'\nimport Tweakpane from 'tweakpane'\nimport { InputtableOutType } from 'tweakpane/dist/types/controller/binding-creators/input'\n\nexport type TweakpaneType = Tweakpane | FolderApi\n\nexport enum SpecialInputTypes {\n  SEPARATOR,\n  FOLDER,\n  BUTTON,\n  MONITOR,\n}\n\nexport type InputConstructor = InputParams & { value: InputtableOutType }\n\nexport interface Schema {\n  [name: string]: InputtableOutType | InputConstructor | Folder | Separator\n}\n\nexport type Settings = Omit<TweakpaneConfig, 'container'> & { container?: React.RefObject<HTMLElement> }\n\nexport interface Monitor {\n  type: SpecialInputTypes\n  title: string\n  ref: any | React.Ref<any> | (() => any)\n  settings: MonitorParams\n}\n\nexport interface Folder<T extends Schema = Schema> {\n  type: SpecialInputTypes\n  title: string\n  schema: T\n  settings: { expanded: boolean }\n}\n\nexport interface Separator {\n  type: SpecialInputTypes\n}\n\nexport interface Button {\n  type: SpecialInputTypes\n  title: string\n  onClick: () => void\n}\n\ntype Join<T, K extends keyof T, P> = '' extends P ? { [i in K]: T[K] } : P\n\n// can probably be optimized ¯\\_(ツ)_/¯\ntype Leaves<T, P extends string | number | symbol = ''> = {\n  0: T extends { schema: any } ? Join<T, 'schema', Leaves<T['schema']>> : never\n  1: T extends { value: any } ? { [i in P]: T['value'] } : never\n  2: never\n  3: { [i in P]: T }\n  4: { [K in keyof T]: Join<T, K, Leaves<T[K], K>> }[keyof T]\n  5: ''\n}[T extends Folder\n  ? 0\n  : T extends InputConstructor\n  ? 1\n  : T extends Separator | Button\n  ? 2\n  : T extends object\n  ? T extends InputtableOutType\n    ? 3\n    : 4\n  : 5]\n\n/**\n * It does nothing but beautify union type\n *\n * ```\n * type A = { a: 'a' } & { b: 'b' } // { a: 'a' } & { b: 'b' }\n * type B = Id<{ a: 'a' } & { b: 'b' }> // { a: 'a', b: 'b' }\n * ```\n */\ntype Id<T> = T extends infer TT ? { [k in keyof TT]: TT[k] } : never\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never\n\nexport type UseTweaksValues<T> = Id<UnionToIntersection<Leaves<T>>>\n\n/*\nfunction useTweaks<T>(schema: T): UseTweaksValues<T> {\n  // @ts-ignore\n  return schema\n}\nconst b = useTweaks({\n  b: 3,\n  _2323: { type: SpecialInputTypes.SEPARATOR },\n  h: { value: 32, min: 0 },\n  _31: {\n    type: SpecialInputTypes.FOLDER,\n    title: 'folder2',\n    schema: {\n      d: 'al',\n      f: 3,\n      position: { value: { x: 0, y: 0 }, min: { x: -1, y: -1 }, max: { x: 1, y: 1 } },\n      color: { r: 255, g: 255, b: 255, a: 1 },\n      offset: { x: 50, y: 25 },\n      _33: {\n        type: SpecialInputTypes.FOLDER,\n        title: 'folder',\n        schema: { c: { value: 'al' }, k: 4 },\n        settings: { expanded: false },\n      },\n    },\n    settings: { expanded: false },\n  },\n})\n*/\n","import { SpecialInputTypes } from './types'\n// @ts-expect-error\nimport get from 'get-value'\n// @ts-expect-error\nimport set from 'set-value'\nimport { Schema, Folder, Button, InputConstructor, TweakpaneType, Monitor } from './types'\nimport { InputParams } from 'tweakpane/dist/types/api/types'\nimport { InputBindingApi } from 'tweakpane/dist/types/api/input-binding'\nimport { ButtonApi } from 'tweakpane/dist/types/api/button'\nimport { SeparatorApi } from 'tweakpane/dist/types/api/separator'\nimport { noCase } from 'change-case'\n\nfunction transformSettings(settings: InputParams) {\n  if (!('options' in settings)) return settings\n\n  if (Array.isArray(settings.options)) {\n    // @ts-expect-error\n    settings.options = settings.options.reduce((acc, option) => ({ ...acc, [option]: option }), {})\n  }\n  return settings\n}\n\ntype Disposable = TweakpaneType | ButtonApi | SeparatorApi | InputBindingApi<any, any>\n\n// DATA will be in the form of\n// DATA = {\n//   root : {\n//     inputs: { input1: value1, input2: value2, ...},\n//     folder1 : {\n//       inputs: { input3: value3, ...}\n//       folder11 : { ... }\n//     },\n//     folder 2 : { ... }\n//     ...\n//   }\n// }\nconst DATA: any = { root: {} }\n\n// this function traverses the schema and sets the initial input values.\n// - if the global DATA object already holds a key matching the schema input,\n//   then the DATA object key value is used as the initial value.\n// - if the global DATA object key is empty, then the DATA object key is\n//   initialized with the schema value.\nexport function getData(schema: Schema, rootPath: string) {\n  const data: Record<string, unknown> = Object.entries(schema).reduce((accValues, [key, input]) => {\n    // the path to the inputs of object in nested folders\n    // we use set and get to access paths such as\n    // DATA.global.folder.nestedFolder.inputs\n    let INPUTS = get(DATA, `${rootPath}.inputs`)\n    // if INPUTS doesn't exist it means that the folder doesn't exist yet,\n    // therefore we need to initialize it first\n    if (!INPUTS) {\n      INPUTS = {}\n      set(DATA, `${rootPath}.inputs`, INPUTS)\n    }\n\n    if (typeof input === 'object') {\n      // Handles any tweakpane object that's not an actual Input\n      if ('type' in input) {\n        // if the input type is a Folder, then we recursively add the folder schema\n        if (input.type === SpecialInputTypes.FOLDER) {\n          const { title, schema } = input as Folder\n          return { ...accValues, ...getData(schema, `${rootPath}.${title}`) }\n        }\n        return { ...accValues }\n      }\n      // if the input is an actual value then we get its value from the\n      // DATA object, and if it isn't set, we set it to the schema value\n      else if ('value' in input) {\n        // input is shaped as in input = { value: value, ...settings}\n        INPUTS[key] = INPUTS[key] ?? (input as InputConstructor).value\n      } else {\n        // input is an object but is shaped as in input = { x: 0, y: 0 }\n        INPUTS[key] = INPUTS[key] ?? input\n      }\n      return { ...accValues, [key]: INPUTS[key] }\n    }\n    // same as above, only this time the input is shaped as in { key: value }\n    // instead of { key: { value: value } }\n    INPUTS[key] = INPUTS[key] ?? input\n    return { ...accValues, [key]: INPUTS[key] }\n  }, {})\n\n  return data\n}\n\n// this function acts similarly to the getData function, only\n// this time the DATA object should be fully initialized, therefore\n// we read its values are used to initialize Tweakpane.\n// It also returns an array of top-level panes that will need to be disposed\n// when the component is unmounted. Note that we only need top-level panes\n// as nested panes will be disposed when their parents are.\nexport function buildPane(\n  schema: Schema,\n  rootPath: string,\n  setValue: (key: string, value: unknown) => void,\n  rootPane: TweakpaneType\n) {\n  // nestedPanes will hold the top level folder references that\n  // will need to be disposed in useTweaks\n  const nestedPanes: Disposable[] = []\n\n  // we read the inputs of the nested path\n  let INPUTS = get(DATA, `${rootPath}.inputs`)\n\n  Object.entries(schema).forEach(([key, input]) => {\n    if (typeof input === 'object') {\n      if ('type' in input) {\n        if (input.type === SpecialInputTypes.MONITOR) {\n          const { title, ref, settings } = input as Monitor\n          let monitor\n          if (typeof ref === 'function') {\n            const myObj = { current: ref() }\n            const updateFn = () => (myObj.current = ref())\n\n            monitor = rootPane.addMonitor(myObj, 'current', { label: title, ...settings }).on('update', updateFn)\n          } else if ('current' in ref) {\n            monitor = rootPane.addMonitor(ref, 'current', { label: title, ...settings })\n          } else {\n            monitor = rootPane.addMonitor(ref, title, settings)\n          }\n          nestedPanes.push(monitor)\n        } else if (input.type === SpecialInputTypes.FOLDER) {\n          // if the input is a Folder, we recursively add the folder structure\n          // to Tweakpane\n          const { title, settings, schema } = input as Folder\n          const folderPane = rootPane.addFolder({ title, ...settings })\n          nestedPanes.push(folderPane)\n          buildPane(schema, `${rootPath}.${title}`, setValue, folderPane)\n        } else if (input.type === SpecialInputTypes.BUTTON) {\n          // Input is a Button\n          const { title, onClick } = input as Button\n          if (typeof onClick !== 'function') throw new Error('Button onClick must be a function.')\n          const button = rootPane.addButton({ title }).on('click', onClick)\n          nestedPanes.push(button)\n        } else if (input.type === SpecialInputTypes.SEPARATOR) {\n          // Input is a separator\n          const separator = rootPane.addSeparator()\n          nestedPanes.push(separator)\n        }\n      } else {\n        const { value, ...settings } = input as InputConstructor\n        const _settings = value !== undefined ? transformSettings(settings) : undefined\n        // we add the INPUTS object to Tweakpane and we listen to changes\n        // to trigger setValue, which will set the useTweaks hook state.\n        const pane = rootPane\n          .addInput(INPUTS, key, { label: noCase(key), ..._settings })\n          .on('change', v => setValue(key, v))\n        nestedPanes.push(pane)\n      }\n    } else {\n      const pane = rootPane.addInput(INPUTS, key, { label: noCase(key) }).on('change', v => setValue(key, v))\n      nestedPanes.push(pane)\n    }\n  }, {})\n\n  return nestedPanes\n}\n","import { useState, useLayoutEffect, useRef } from 'react'\nimport Tweakpane from 'tweakpane'\n\nimport { getData, buildPane } from './data'\nimport { Schema, Settings, UseTweaksValues } from './types'\n\nlet ROOTPANE: Tweakpane | undefined\n\nexport function useTweaks<T extends Schema>(schema: T, settings?: Settings): UseTweaksValues<T>\nexport function useTweaks<T extends Schema>(name: string, schema: T, settings?: Settings): UseTweaksValues<T>\nexport function useTweaks<T extends Schema>(\n  nameOrSchema: string | T,\n  schemaOrSettings?: T | Settings | undefined,\n  settings?: Settings\n): UseTweaksValues<T> {\n  const _name = typeof nameOrSchema === 'string' ? nameOrSchema : undefined\n  const _rootKey = typeof nameOrSchema === 'string' ? 'root.' + nameOrSchema : 'root'\n  const _settings = useRef(typeof nameOrSchema === 'string' ? settings : (schemaOrSettings as Settings))\n  const _schema = useRef(typeof nameOrSchema === 'string' ? (schemaOrSettings as T) : nameOrSchema)\n\n  const [data, set] = useState(() => getData(_schema.current, _rootKey))\n\n  useLayoutEffect(() => {\n    ROOTPANE = ROOTPANE || new Tweakpane({ ..._settings, container: _settings.current?.container?.current! })\n    const isRoot = _name === undefined\n    const _pane = _name ? ROOTPANE.addFolder({ title: _name }) : ROOTPANE\n    const setValue = (key: string, value: unknown) => set(data => ({ ...data, [key]: value }))\n    const disposablePanes = buildPane(_schema.current, _rootKey, setValue, _pane)\n\n    return () => {\n      if (!isRoot) _pane.dispose()\n      // we only need to dispose the parentFolder\n      else disposablePanes.forEach(d => d.dispose())\n    }\n  }, [_name, _rootKey])\n\n  return data as UseTweaksValues<T>\n}\n","import { MonitorParams } from 'tweakpane/dist/types/api/types'\nimport { SpecialInputTypes, Schema, Separator, Folder, Button, Monitor } from './types'\n\nlet separatorCount = 0\n\nexport function makeSeparator(): Record<string, Separator> {\n  return {\n    [`_s_${separatorCount++}`]: { type: SpecialInputTypes.SEPARATOR },\n  }\n}\n\nexport function makeFolder<T extends Schema, P extends string>(title: P, schema: T, expanded = true) {\n  return ({\n    [`_f_${title}`]: { type: SpecialInputTypes.FOLDER, title, schema, settings: { expanded } },\n  } as unknown) as Record<P, Folder<T>>\n}\n\nexport const makeDirectory = makeFolder\n\nexport function makeButton(title: string, onClick: () => void): Record<string, Button> {\n  return {\n    [`_b_${title}`]: { type: SpecialInputTypes.BUTTON, title, onClick },\n  }\n}\n\nexport function makeMonitor(\n  title: string,\n  ref: any | React.Ref<any> | (() => any),\n  settings: MonitorParams\n): Record<string, Monitor> {\n  return {\n    [`_m_${title}`]: {\n      type: SpecialInputTypes.MONITOR,\n      title,\n      ref,\n      settings,\n    },\n  }\n}\n"],"names":["SpecialInputTypes","ROOTPANE","DATA","root","getData","schema","rootPath","Object","entries","reduce","accValues","key","input","INPUTS","get","set","type","FOLDER","title","value","separatorCount","makeFolder","expanded","settings","makeDirectory","onClick","BUTTON","ref","MONITOR","SEPARATOR","nameOrSchema","schemaOrSettings","_name","undefined","_rootKey","_settings","useRef","_schema","useState","current","data","useLayoutEffect","Tweakpane","container","_settings$current","_settings$current$con","isRoot","_pane","addFolder","disposablePanes","buildPane","setValue","rootPane","nestedPanes","forEach","monitor","myObj","addMonitor","label","on","push","folderPane","Error","button","addButton","separator","addSeparator","Array","isArray","options","acc","option","transformSettings","pane","addInput","noCase","v","d","dispose"],"mappings":"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"}