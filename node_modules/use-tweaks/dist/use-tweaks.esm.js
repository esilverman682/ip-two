import { useRef, useState, useLayoutEffect } from 'react';
import Tweakpane from 'tweakpane';
import get from 'get-value';
import set from 'set-value';
import { noCase } from 'change-case';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var SpecialInputTypes;

(function (SpecialInputTypes) {
  SpecialInputTypes[SpecialInputTypes["SEPARATOR"] = 0] = "SEPARATOR";
  SpecialInputTypes[SpecialInputTypes["FOLDER"] = 1] = "FOLDER";
  SpecialInputTypes[SpecialInputTypes["BUTTON"] = 2] = "BUTTON";
  SpecialInputTypes[SpecialInputTypes["MONITOR"] = 3] = "MONITOR";
})(SpecialInputTypes || (SpecialInputTypes = {}));
/*
function useTweaks<T>(schema: T): UseTweaksValues<T> {
  // @ts-ignore
  return schema
}
const b = useTweaks({
  b: 3,
  _2323: { type: SpecialInputTypes.SEPARATOR },
  h: { value: 32, min: 0 },
  _31: {
    type: SpecialInputTypes.FOLDER,
    title: 'folder2',
    schema: {
      d: 'al',
      f: 3,
      position: { value: { x: 0, y: 0 }, min: { x: -1, y: -1 }, max: { x: 1, y: 1 } },
      color: { r: 255, g: 255, b: 255, a: 1 },
      offset: { x: 50, y: 25 },
      _33: {
        type: SpecialInputTypes.FOLDER,
        title: 'folder',
        schema: { c: { value: 'al' }, k: 4 },
        settings: { expanded: false },
      },
    },
    settings: { expanded: false },
  },
})
*/

function transformSettings(settings) {
  if (!('options' in settings)) return settings;

  if (Array.isArray(settings.options)) {
    // @ts-expect-error
    settings.options = settings.options.reduce(function (acc, option) {
      var _extends2;

      return _extends({}, acc, (_extends2 = {}, _extends2[option] = option, _extends2));
    }, {});
  }

  return settings;
} // DATA will be in the form of
// DATA = {
//   root : {
//     inputs: { input1: value1, input2: value2, ...},
//     folder1 : {
//       inputs: { input3: value3, ...}
//       folder11 : { ... }
//     },
//     folder 2 : { ... }
//     ...
//   }
// }


var DATA = {
  root: {}
}; // this function traverses the schema and sets the initial input values.
// - if the global DATA object already holds a key matching the schema input,
//   then the DATA object key value is used as the initial value.
// - if the global DATA object key is empty, then the DATA object key is
//   initialized with the schema value.

function getData(schema, rootPath) {
  var data = Object.entries(schema).reduce(function (accValues, _ref) {
    var _INPUTS$key3, _extends4;

    var key = _ref[0],
        input = _ref[1];
    // the path to the inputs of object in nested folders
    // we use set and get to access paths such as
    // DATA.global.folder.nestedFolder.inputs
    var INPUTS = get(DATA, rootPath + ".inputs"); // if INPUTS doesn't exist it means that the folder doesn't exist yet,
    // therefore we need to initialize it first

    if (!INPUTS) {
      INPUTS = {};
      set(DATA, rootPath + ".inputs", INPUTS);
    }

    if (typeof input === 'object') {
      var _extends3;

      // Handles any tweakpane object that's not an actual Input
      if ('type' in input) {
        // if the input type is a Folder, then we recursively add the folder schema
        if (input.type === SpecialInputTypes.FOLDER) {
          var title = input.title,
              _schema = input.schema;
          return _extends({}, accValues, getData(_schema, rootPath + "." + title));
        }

        return _extends({}, accValues);
      } // if the input is an actual value then we get its value from the
      // DATA object, and if it isn't set, we set it to the schema value
      else if ('value' in input) {
          var _INPUTS$key;

          // input is shaped as in input = { value: value, ...settings}
          INPUTS[key] = (_INPUTS$key = INPUTS[key]) != null ? _INPUTS$key : input.value;
        } else {
          var _INPUTS$key2;

          // input is an object but is shaped as in input = { x: 0, y: 0 }
          INPUTS[key] = (_INPUTS$key2 = INPUTS[key]) != null ? _INPUTS$key2 : input;
        }

      return _extends({}, accValues, (_extends3 = {}, _extends3[key] = INPUTS[key], _extends3));
    } // same as above, only this time the input is shaped as in { key: value }
    // instead of { key: { value: value } }


    INPUTS[key] = (_INPUTS$key3 = INPUTS[key]) != null ? _INPUTS$key3 : input;
    return _extends({}, accValues, (_extends4 = {}, _extends4[key] = INPUTS[key], _extends4));
  }, {});
  return data;
} // this function acts similarly to the getData function, only
// this time the DATA object should be fully initialized, therefore
// we read its values are used to initialize Tweakpane.
// It also returns an array of top-level panes that will need to be disposed
// when the component is unmounted. Note that we only need top-level panes
// as nested panes will be disposed when their parents are.

function buildPane(schema, rootPath, setValue, rootPane) {
  // nestedPanes will hold the top level folder references that
  // will need to be disposed in useTweaks
  var nestedPanes = []; // we read the inputs of the nested path

  var INPUTS = get(DATA, rootPath + ".inputs");
  Object.entries(schema).forEach(function (_ref2) {
    var key = _ref2[0],
        input = _ref2[1];

    if (typeof input === 'object') {
      if ('type' in input) {
        if (input.type === SpecialInputTypes.MONITOR) {
          var title = input.title,
              ref = input.ref,
              settings = input.settings;
          var monitor;

          if (typeof ref === 'function') {
            var myObj = {
              current: ref()
            };

            var updateFn = function updateFn() {
              return myObj.current = ref();
            };

            monitor = rootPane.addMonitor(myObj, 'current', _extends({
              label: title
            }, settings)).on('update', updateFn);
          } else if ('current' in ref) {
            monitor = rootPane.addMonitor(ref, 'current', _extends({
              label: title
            }, settings));
          } else {
            monitor = rootPane.addMonitor(ref, title, settings);
          }

          nestedPanes.push(monitor);
        } else if (input.type === SpecialInputTypes.FOLDER) {
          // if the input is a Folder, we recursively add the folder structure
          // to Tweakpane
          var _title = input.title,
              _settings2 = input.settings,
              _schema2 = input.schema;
          var folderPane = rootPane.addFolder(_extends({
            title: _title
          }, _settings2));
          nestedPanes.push(folderPane);
          buildPane(_schema2, rootPath + "." + _title, setValue, folderPane);
        } else if (input.type === SpecialInputTypes.BUTTON) {
          // Input is a Button
          var _title2 = input.title,
              onClick = input.onClick;
          if (typeof onClick !== 'function') throw new Error('Button onClick must be a function.');
          var button = rootPane.addButton({
            title: _title2
          }).on('click', onClick);
          nestedPanes.push(button);
        } else if (input.type === SpecialInputTypes.SEPARATOR) {
          // Input is a separator
          var separator = rootPane.addSeparator();
          nestedPanes.push(separator);
        }
      } else {
        var value = input.value,
            _settings3 = _objectWithoutPropertiesLoose(input, ["value"]);

        var _settings = value !== undefined ? transformSettings(_settings3) : undefined; // we add the INPUTS object to Tweakpane and we listen to changes
        // to trigger setValue, which will set the useTweaks hook state.


        var pane = rootPane.addInput(INPUTS, key, _extends({
          label: noCase(key)
        }, _settings)).on('change', function (v) {
          return setValue(key, v);
        });
        nestedPanes.push(pane);
      }
    } else {
      var _pane = rootPane.addInput(INPUTS, key, {
        label: noCase(key)
      }).on('change', function (v) {
        return setValue(key, v);
      });

      nestedPanes.push(_pane);
    }
  }, {});
  return nestedPanes;
}

var ROOTPANE;
function useTweaks(nameOrSchema, schemaOrSettings, settings) {
  var _name = typeof nameOrSchema === 'string' ? nameOrSchema : undefined;

  var _rootKey = typeof nameOrSchema === 'string' ? 'root.' + nameOrSchema : 'root';

  var _settings = useRef(typeof nameOrSchema === 'string' ? settings : schemaOrSettings);

  var _schema = useRef(typeof nameOrSchema === 'string' ? schemaOrSettings : nameOrSchema);

  var _useState = useState(function () {
    return getData(_schema.current, _rootKey);
  }),
      data = _useState[0],
      set = _useState[1];

  useLayoutEffect(function () {
    var _settings$current, _settings$current$con;

    ROOTPANE = ROOTPANE || new Tweakpane(_extends({}, _settings, {
      container: (_settings$current = _settings.current) == null ? void 0 : (_settings$current$con = _settings$current.container) == null ? void 0 : _settings$current$con.current
    }));
    var isRoot = _name === undefined;

    var _pane = _name ? ROOTPANE.addFolder({
      title: _name
    }) : ROOTPANE;

    var setValue = function setValue(key, value) {
      return set(function (data) {
        var _extends2;

        return _extends({}, data, (_extends2 = {}, _extends2[key] = value, _extends2));
      });
    };

    var disposablePanes = buildPane(_schema.current, _rootKey, setValue, _pane);
    return function () {
      if (!isRoot) _pane.dispose(); // we only need to dispose the parentFolder
      else disposablePanes.forEach(function (d) {
          return d.dispose();
        });
    };
  }, [_name, _rootKey]);
  return data;
}

var separatorCount = 0;
function makeSeparator() {
  var _ref;

  return _ref = {}, _ref["_s_" + separatorCount++] = {
    type: SpecialInputTypes.SEPARATOR
  }, _ref;
}
function makeFolder(title, schema, expanded) {
  var _ref2;

  if (expanded === void 0) {
    expanded = true;
  }

  return _ref2 = {}, _ref2["_f_" + title] = {
    type: SpecialInputTypes.FOLDER,
    title: title,
    schema: schema,
    settings: {
      expanded: expanded
    }
  }, _ref2;
}
var makeDirectory = makeFolder;
function makeButton(title, onClick) {
  var _ref3;

  return _ref3 = {}, _ref3["_b_" + title] = {
    type: SpecialInputTypes.BUTTON,
    title: title,
    onClick: onClick
  }, _ref3;
}
function makeMonitor(title, ref, settings) {
  var _ref4;

  return _ref4 = {}, _ref4["_m_" + title] = {
    type: SpecialInputTypes.MONITOR,
    title: title,
    ref: ref,
    settings: settings
  }, _ref4;
}

export { makeButton, makeDirectory, makeFolder, makeMonitor, makeSeparator, useTweaks };
//# sourceMappingURL=use-tweaks.esm.js.map
